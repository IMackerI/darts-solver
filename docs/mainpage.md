
@mainpage Darts Solver Documentation

@section intro Introduction
This library finds the optimal aiming strategy for darts games using
dynamic programming and probability theory. Given a dartboard layout and
a probability distribution modeling throwing accuracy, the solver computes
the best point to aim at for any game state to minimize the expected 
number of throws to finish.

@section modules Modules
The library is organized into the following modules:

- @ref geometry - 2D vectors and polygons for representing dartboards
- @ref distributions - Probability distributions for modeling throwing accuracy
- @ref game - Game rules and dartboard targets
- @ref solver - Optimal strategy computation

@section quickstart Quick Start
@code
// Load a dartboard
Target board("dartboard.txt");

// Create throwing distribution (2D Gaussian with std dev = 2)
NormalDistribution::covariance cov = {{{2.0, 0.0}, {0.0, 2.0}}};
NormalDistributionRandom dist(cov, Vec2{0,0}, 10000);

// Set up game with standard darts rules
GameFinishOnDouble game(board, dist);

// Solve for optimal strategy from 501 points
Solver solver(game, 5000);
auto [expected_throws, best_aim] = solver.solve(501);

std::cout << "Expected throws to finish: " << expected_throws << std::endl;
std::cout << "Best aim point: (" << best_aim.x << ", " << best_aim.y << ")" << std::endl;
@endcode

@section web Web Frontend
The interactive web application in `src/web/` lets users calibrate their
throwing distribution and compute optimal strategies directly in the browser.
It communicates with the C++ solver via a WebAssembly module compiled with Emscripten.

@note The web frontend (HTML, CSS, and JavaScript under `src/web/`) was generated
mostly by AI (GitHub Copilot) and serves as a thin UI layer over the C++ logic.

@section features Key Features

- **Multiple integration methods**: I have implemented both Monte Carlo (fast, approximate)
  and Gauss quadrature (exact for polynomial densities), but currently Quadrature is in use, as it is much better.
- **Flexible game rules**: Support for standard finish-on-double rules or simpler variants
- **Efficient solving**: Dynamic programming with memoization for optimal performance
- **Heat map generation**: Visualize the quality of all possible aim points

@section algorithm Algorithm Overview

@subsection Distribution Modeling

- The probability distribution can be estimated from real throwing data. This is done by fitting a 2D Gaussian simply by computing the sample mean and covariance of the throw coordinates.

@subsection Throw Outcome Computation

- To compute the outcome of a single throw we sample from the distribution and check which target segment it lands in. I check which polygon (representing a segment) contains the sampled point by casting a ray and counting intersections.

- To compute all the possible probabilities of outcomes, the function is integrated over individual polygons of the beds of the dartboard. This can be done using Monte Carlo sampling or Gauss quadrature. Gaus quadrature is more accurate and faster for this problem, as the density is smooth and the segments are polygonal.

- The probabilities of outcomes are cached to avoid redundant computations, as for many different states the points to aim at are the same. This has increased the speed by almost a factor of 100.

@subsection Dynamic Programming Solver

- Using the dynamic programming approach, we can assume the lower states are already solved. We then compute the expected number of throws for one aim point by iterating over all possible outcomes. For lower states, we know the number of throws to finish, the other option is that we miss. We calculate the probability of missing and solve a recursive equation to get the expected number of throws for that aim point. 

- We repeat this for all aim points and take the minimum as the solution for that state.

@subsection Other

- The greedy solver simply computes the expected points scored for each aim point and chooses the one that maximizes it. This is much faster and is a good approximation for higher states.

- The game mode is given by the Game class, which defines the transitions between states and the winning conditions. The solver is agnostic to the game rules, as long as the Game class provides the necessary interface and keeps the state transitions monotone (i.e. you can't go back to a higher state).

- The heat map is generated by computing the expected throws for a grid of aim points and visualizing it with a color map. This helps to see which areas of the board are better to aim at for a given state.
